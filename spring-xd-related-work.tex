\section{Related Work}
This section compares and contrasts Spring XD to similar projects.

\subsection{Spark}
\label{sec:Spark}
Apache Spark is a general purpose framework for large scale data processing.
In comparison with Hadoop's disk based MapReduce programming model, Spark's
in-memory primitives yields performance improvements.

The following features differentiate Spring XD and Spark Streaming.

\begin{itemize*}
\item Ability to microbatch based on event count via Reactor and RxJava APIs.
\item Ability to create data pipelines to process one event at a time.
\item Flexibility to specify hosts to dictate the location of data computations.
\end{itemize*}

The following features differentiate Spring XD and Spark Batch processing.

\begin{itemize*}
\item Provides REST-API and lifecycle management for Spark jobs.
\item Extensible to integrate with other batch systems.
\end{itemize*}

Recognizing the strengths of distributed data computations with Spark, Spring XD
supports integration with Spark applications such as Spark Streaming, MLLib, and
SparkSQL. Users familiar with Spark may implement the computation logic using
Spark APIs in Java or Scala, and leave the orchestration to Spring XD.
The Spring XD Spark module acts as the driver while the computation defined
by the streaming application is executed in the Spark cluster. Driver failure
is automatically handled by Spring XD -- the admin server will re-deploy a
module from a failed container to another eligible container.

\subsection{Storm}
Apache Storm\cite{storm} is a distributed computation system for real time stream
processing.

The following features differentiate Spring XD and Storm.

\begin{itemize*}
\item Spring XD provides an interactive shell while Storm requires programming
to an API to create data pipelines.
\item Use of \emph{taps} in Spring XD allows the creation of stream pipelines
in isolation without having to disrupt existing pipelines.
\item Loosely coupled modules in Spring XD are responsible for ingestion, analytics,
data processing, machine learning or data export. Modules can be individually managed
and dynamically scaled. Additionally modules may be co-located to minimize
serialization and network usage.
\item Building upon the functional stream processing model, users have the option
to choose from Reactor\cite{reactor}, Spark Streaming or RxJava APIs to build
complex data centric applications.
\item As an alternative to linear streaming data pipelines, Spring XD provides
support for directed graphs through named channels to combine multiple flows
upstream or downstream from the message channel. The behavior of the channel
can be either queue-based on topic-based. However, Storm accepts Directed
Acyclic Graph (DAG)\cite{dag} of operations that represent streaming
computations.\\*

Here is a Spring XD example that shows how you can use a named channel to share
a data pipeline driven by different input sources.\\*

\verb;queue:foo > file;\\*
\verb;http > queue:foo;\\*
\verb;time > queue:foo;\\*

Now if you post data to the http source, you will see that data intermingled
with the time value in the file.\\*

\verb;tap:stream:mystream > file;\\*
\verb;tap:stream:mystream > log;

\end{itemize*}

Storm and Spring XD support many common data sources and middleware;
for example, the reading and writing of data payloads from Apache Kafka
is supported in both. A Spout in Storm is analogous to a
source in Spring XD, and Bolts in Storm are similar to processors and sinks
in Spring XD. As stream processing frameworks, Storm and Spring XD can be used for
similar use-cases.

\subsection{Samza}
Apache Samza\cite{samza} is a distributed stream processing framework that uses
Kafka for messaging and YARN for fault-tolerance and other non-functional
requirements.

The following features differentiate Spring XD and Samza.

\begin{itemize*}
\item Spring XD provides out of the box adapters for reading and writing to a wide
variety of enterprise systems, while Samza requires the end user to provide their
own implementations, using Samza's API.
\item Batch processing in Samza is treated as particular case of stream
processing, by moving data to Kafka and processing. This is generally good,
unless the entire dataset needs processed as a whole. The bi-directional
communication between stream and batch processing in Spring XD, allows construction
of complex chains of data processing.
\item Spring XD's runtime abstraction allows extensions and additional
customizations. Though extensible, the implementation in Samza should comply with
Samza-compatible streaming system, which generally means it is very much Kafka
or similar.
\item Spring XD provides built-in fault-tolerance, security, and logging; whereas,
Samza relies on YARN to support non-functional requirements.
\item Spring XD's YARN support provides cluster/group semantics, which allows
ramping up/down and also creating such groups dynamically. The container `count'
in Samza is static - requires redeployment to rebalance scaling of containers.
\end{itemize*}

Samza offers local-state repository with the option of log-backed replication,
which could be desirable as a standalone general purpose resilient cache, and it
is planned for our upcoming releases.

\subsection{Flume}
Apache Flume\cite{flume} is a distributed system for collecting, aggregating and
moving large data sets.

The following features differentiate Spring XD and Flume.

\begin{itemize*}
\item Spring XD uses an interactive shell and DSL for stream creation,
while Flume uses property (key/value pair) files.
\item Administration and monitoring via the admin UI.
\item Granular controls to manifest batch job and step execution to create
complex data driven workflows.
\item Flexibility through a deployment manifest to declaratively configure data
partitioning strategy to route data to a specific consumer instance in the cluster.
\end{itemize*}

Flume offers HBase, Solr, and ElasticSearch sinks along with encryption support
for Avro sources, which we are planning to address in our future releases.

\subsection{Oozie}
Apache Oozie\cite{oozie} is a workflow scheduler engine to manage Hadoop \cite{hadoop}
workloads such as MapReduce or Pig jobs.

The following features differentiate Spring XD and Oozie.

\begin{itemize*}
\item Building upon Spring Batch, a JSR standardization (JSR-352) of batch
workload data processing, Spring XD inherits workflow scheduling and execution
functionalities.
\item Provides out of the box batch jobs that support plain files, JDBC, HDFS,
FTP, MongoDB, Spark and Sqoop.
\item Ability to scale jobs without having to bring down the runtime.
\item Provides bi-directionality between real-time streaming and batch
workflows to accommodate complex data processing use cases.
\item Ability to create, and launch jobs from the admin UI.
\item Ability to view historical snapshots of job executions from the admin UI.
\end{itemize*}

Oozie offers HCatalog integration, which we are planning to address in our
future releases.

\subsection{Sqoop}
Apache Sqoop\cite{sqoop} assists with data transmission between Hadoop and relational
databases.

The following features differentiate Spring XD and Sqoop.

\begin{itemize*}
\item Ability to orchestrate Pig, Hive, HBase, MapReduce or other batch systems.
\item Flexibility to extend and customize batch workflow infrastructure.
\item High level configuration DSL to create, deploy and destroy batch workflows.
\item Flexibility to operationalize custom data pipelines through REST.
\item Unified functional programming support to build reactive-style data pipelines.
\end{itemize*}

Sqoop offers data validation and HCatalog integration among others. Recognizing the
importance of these enterprise features, Spring XD provides an out of the box Sqoop
job to take advantage of these features.
