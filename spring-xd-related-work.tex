\section{Related Work}
This section compares and contrasts Spring XD to similar projects.

\subsection{Spark}
\label{sec:Spark}
Apache Spark is a general purpose framework for large scale data processing.
In comparison with Hadoop's disk based MapReduce programming model, Spark's
in-memory primitives yields performance improvements.

The following features differentiate Spring XD and Spark Streaming.

\begin{itemize*}
\item Ability to microbatch based on event count via Reactor and RxJava APIs.
\item Ability to create data pipelines to process one event at a time.
\item Flexibility to specify hosts to dictate the location of data computations.
\end{itemize*}

The following features differentiate Spring XD and Spark Batch processing.

\begin{itemize*}
\item Provides REST-API and lifecycle management for Spark jobs.
\item Extensible to integrate with other batch systems.
\end{itemize*}

Recognizing the strengths of distributed data computations with Spark, Spring XD
supports integration with Spark applications such as Spark Streaming, MLLib, and
SparkSQL. Users familiar with Spark may implement the computation logic using
Spark APIs in Java or Scala, and leave the orchestration to Spring XD.

\subsubsection{Integration with any Spark application}
A Spark Application can be deployed and launched from Spring XD as
a \emph{batch} job. A Spring XD batch job submits the Spark application into
Spark cluster manager using \texttt{org.apache.spark.deploy.SparkSubmit}. An advantage
of this approach is that one can launch a Spark application with specific criteria
via a Spring XD stream. For instance, a real time scoring algorithm through Spark MLlib
job can be triggered based on the criteria from a regular stream events.
Another advantage is after the job is complete a notification can be sent to a
stream for processing.

\subsubsection{Integration with Spark Streaming}
Spring XD integrates with Spark streaming to provide better orchestration and
lifecycle management for Spark streaming applications. Spring XD runs the
Spark Driver as a module (processor or sink) in the Spring XD container
while the \emph{spark streaming receiver} and subsequent \emph{data computation} is
done at the \emph{Spark Cluster}. Driver failure is automatically handled by
Spring XD -- the admin server will re-deploy a module from a failed container
to another eligible container.
Setting up a Spark Streaming module within XD can be beneficial when adding
streaming data computation logic for a tapped Spring XD stream. While the primary
stream processes events one at a time (through the regular Spring XD modules),
the tapped stream will become a source for the Spark Streaming module.

\subsection{Storm}
Apache Storm\cite{storm} is a distributed computation system for real time stream
processing.

The following features differentiate Spring XD and Storm.

\begin{itemize*}
\item Spring XD provides an interactive shell while Storm requires programming
to an API to create data pipelines.
\item Use of \emph{taps} in Spring XD allows the creation of stream pipelines
in isolation without having to disrupt existing pipelines.
\item Loosely coupled modules in Spring XD are responsible for ingestion, analytics,
data processing, machine learning or data export. Modules can be individually managed
and dynamically scaled. Additionally modules may be co-located to minimize
serialization and network usage.
\item Building upon the functional stream processing model, users have the option
to choose from Reactor\cite{reactor}, Spark Streaming or RxJava APIs to build
complex data centric applications.
\end{itemize*}

Storm uses Directed Acyclic Graphs (DAG)\cite{dag} to represent
their data flow topologies. The nodes of a Storm DAG graph are \emph{spouts}
(sources in Spring XD) and \emph{bolts} (processors and sinks
in Spring XD). Although streams in Spring XD are linear pipelines,
data flows similar to DAGs can be modeled in Spring XD by connecting 
multiple streams via named queues.

Here is an example of a named channel to share a data pipeline driven
by different input sources:

\begin{lstlisting}
queue:inbound > file
http > queue:inbound
time > queue:inbound
\end{lstlisting}

Data posted to the \emph{http} source will be intermingled with timestamps
generated by the \emph{time} source in the file created by the \emph{file} 
sink.

Storm and Spring XD support many common data sources and middleware;
for example, the reading and writing of data payloads from Apache Kafka
is supported in both. As stream processing frameworks, Storm and Spring 
XD can be used for similar use-cases.

\subsection{Samza}
Apache Samza\cite{samza} is a distributed stream processing framework that uses
Kafka for messaging and YARN for fault-tolerance and other non-functional
requirements.

The following features differentiate Spring XD and Samza.

\begin{itemize*}
\item Spring XD provides sources and sinks for reading and writing to a 
variety systems, while Samza requires the end user to provide their
own implementations, using Samza's API.
\item Spring XD's runtime abstraction allows extensions and additional
customizations. Though extensible, the implementation in Samza should comply with
Samza-compatible streaming system, which generally means it is very much Kafka
or similar.
\item Spring XD provides built-in fault-tolerance, security, and logging; whereas,
Samza relies on YARN to support non-functional requirements.
\item Spring XD's YARN support provides cluster/group semantics, which allows
ramping up/down and also creating such groups dynamically. The container `count'
in Samza is static - requires redeployment to rebalance scaling of containers.
\end{itemize*}

Samza offers local-state repository with the option of log-backed replication,
which could be desirable as a standalone general purpose resilient cache.

\subsection{Flume}
Apache Flume\cite{flume} is a distributed system for collecting, aggregating and
moving large data sets.

The following features differentiate Spring XD and Flume.

\begin{itemize*}
\item Spring XD uses an interactive shell and DSL for stream creation,
while Flume uses property (key/value pair) files.
\item Administration and monitoring via the admin UI.
\item Granular controls to manifest batch job and step execution to create
complex data driven workflows.
\item Flexibility through a deployment manifest to declaratively configure data
partitioning strategy to route data to a specific consumer instance in the cluster.
\end{itemize*}

Flume offers HBase, Solr, and ElasticSearch sinks along with encryption support
for Avro sources, which we are planning to address in our future releases.

\subsection{Oozie}
Apache Oozie\cite{oozie} is a workflow scheduler engine to manage Hadoop \cite{hadoop}
workloads such as MapReduce or Pig jobs.

The following features differentiate Spring XD and Oozie.

\begin{itemize*}
\item Building upon Spring Batch, a JSR standardization (JSR-352) of batch
workload data processing, Spring XD inherits workflow scheduling and execution
functionalities.
\item Provides out of the box batch jobs that support plain files, JDBC, HDFS,
FTP, MongoDB, Spark and Sqoop.
\item Ability to scale jobs without having to bring down the runtime.
\item Provides bi-directionality between real-time streaming and batch
workflows to accommodate complex data processing use cases.
\item Ability to create, and launch jobs from the admin UI.
\item Ability to view historical snapshots of job executions from the admin UI.
\end{itemize*}

Oozie offers HCatalog integration, which we are planning to address in our
future releases.

\subsection{Sqoop}
Apache Sqoop\cite{sqoop} assists with data transmission between Hadoop and relational
databases.

The following features differentiate Spring XD and Sqoop.

\begin{itemize*}
\item Ability to orchestrate Pig, Hive, HBase, MapReduce or other batch systems.
\item Flexibility to extend and customize batch workflow infrastructure.
\item High level configuration DSL to create, deploy and destroy batch workflows.
\item Flexibility to operationalize custom data pipelines through REST.
\item Unified functional programming support to build reactive-style data pipelines.
\end{itemize*}

Sqoop offers data validation and HCatalog integration among others. Recognizing the
importance of these enterprise features, Spring XD provides an out of the box Sqoop
job to take advantage of these features.
