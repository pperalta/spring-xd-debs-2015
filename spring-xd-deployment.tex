\section{Deployment}
This section describes deployment architectures that are possible with Spring XD.
Note that this is not an exhaustive list of all deployment types. See
section~\ref{sec:Use Cases} for descriptions of real world deployments.

\subsection{Lambda architecture}

The Lambda Architecture, introduced by Nathan Marz \cite{lambda-architecture-paper}
is a generic, scalable and fault tolerant data  processing architecture. It 
attemptsto provide a comprehensive solution to the problem of processing an 
extremely largeset of data.

The Lambda Architecture has the following components:

\begin{itemize*}
\item A \emph{master dataset} comprising of all data known to the system,
ideally in its rawest form;
\item A \emph{serving} or \emph{view layer} that provides the latest,
most up-to-date view of the processed data, available for low-latency,
ad-hoc querying;
\item A \emph{batch layer} that performs computationally intense 
calculations that and prepares the \emph{batch views} displayed by the 
\emph{serving layer};
\item A \emph{speed layer} that performs calculations on recent data only, 
its output combined with the \emph{batch views} by the \emph{serving layer}.
\end{itemize*}

The guiding principle of the Lambda architecture is an attempt to combine the
high throughput of batch operations with the low latency of real-time
computations. Each on its own, has its strengths and weakness. While the
highest throughput for computing large datasets is attained by relying on
batch computations, the latter have the disadvantage of higher latency.
Meanwhile, real-time computations may operate with low latency and produce
results based on latest data quickly, but can't really handle the large
amounts of data that batch processing can deal with. So, instead of relying
on a single paradigm, the lambda architecture employs both, allowing them
to complement each other.

A detailed view of the Lambda Architecture can be viewed in figure [TBD].

In the following subsections we will examine how the different components
of the Lambda architecture can be implemented with Spring XD.

\subsubsection {Master dataset in Spring XD}

While Spring XD does not provide a storage mechanism of its own, it 
integrates with a variety of storage technologies, both for reading,
via its source[reference tbd] components, as well as for writing, via 
its sink[reference tbd, provide examples] components. A \emph{data ingestion}
stream can be used to consolidate data from external sources into a
central storage, where it can wait processing.

For example, the following stream definition can be used to ingest 
MQTT data sent by a number of sensors directly into HDFS:

\verb;stream create ingest --definition "mqtt | hdfs";\\*

In a more elaborate setting, an application can collect data from
different sources, and Spring XD can provide a means to merge them
in a single master dataset. The streams \texttt{in-mqtt} and \texttt{in-http}
collect data from sensors via MQTT and HTTP, respectively, and
contribute to a single queue \texttt{hdfs-in}. The merged result
is saved into HDFS.

\verb;stream create in-mqtt --definition ;\\*
\verb;  "mqtt > queue:hdfs-in";\\*

\verb;stream create in-http --definition  ;\\*
\verb;  "http > queue:hdfs-in";\\*

\verb;stream create ingest --definition  ;\\*
\verb;  "queue:hdfs-in > hdfs";\\*

\subsubsection {Batch layer in Spring XD}

Once data is collected into the \emph{master dataset}, it can be processed
by \emph{jobs} (see \ref{batch-jobs}). The similarities between Spring XD's
notion of a \emph{job} and Lambda Architecture's corresponding notion of
a \emph{batch job} make the mapping fairly straighforward.


The data ingested in the master dataset can be consumed by a batch job,
created as follows:

\verb;job create sensorProcess;\\*
\verb;  --definition "sensors";\\*

(This example already assumes an existing module job named \emph{sensors} that
implements the processing logic).

Spring XD supports the partitioning of jobs for concurrent execution on
separate containers. This allows for maximum efficiency and reduced latency
for job executions. Such execution parameters are defined during deployment,
as follows:

\verb;job deploy sensor-process;\\*
\verb;  --properties module.sensorProcess.count=3;\\*

An important characteristic of the \emph{batch layer} is the regular
execution of jobs, as well as the ability of replaying older datasets, for
instance for reconstructing the \emph{data views} in case of loss or error.
For that, Spring XD provides the following mechanisms:

\begin{itemize*}
\item \emph{manual} job launch through its shell user interface or 
administrative UI;
\item \emph{stream-controlled} where the jobs are lanched by stream of 
\emph{trigger} messages;
\item \emph{scheduled} job launch according to a \texttt{cron} expression;
\end{itemize*}

For example, a job can be launched manually as follows:

\verb;job launch sensor-process;\\*

Or, more typically, it can be launched on a schedule:

\verb;stream create --name launchSensorProcess;\\*
\verb; --definition "trigger --cron='0/5 * * * * *';\\* 
\verb;    > queue:job:myCronJob" --deploy;\\*

\subsubsection {Speed layer in Spring XD}

The role of the \emph{speed layer} is to complement the \emph{batch layer} 
by performing real-time computations on the incoming data, thus filling the 
inherent latency gap. This functionality can be implemented in Spring XD by the 
\ref{analytics} support, more specifically taps, counters, and analytics.

Considering the previous example, while ingesting data from sensors and 
populating the master dataset, the application may perform various computations 
on the datastream. For example, it can perform a count of the incoming elements. 

\verb;stream create count --definition  ;\\*
\verb;"tap:stream:ingest > aggregate-counter";\\*

In a more elaborate scenario, it is possible to actually do 
some processing of the data in-flight and store the results in real-time views
for being combinedwith the batch views.

\verb;stream create count --definition  ;\\*
\verb;"tap:stream:ingest > extract-tags | jdbc";\\*

\subsubsection {View layer in Spring XD}

Externalized via sinks, output of batch jobs. Microservice architecture
Example of a web application reading data off a set of tables
written on by Spring XD. 

\subsubsection {Combining the two}

Stream-driven batch jobs. Taps. 


\subsubsection {Critique of the Lambda Architecture and Spring XD}

An often raised objection to the LA is the duplication of work
(Quote Jay Kreps) that occurs during processing. More specifically,
the necessity of writing the same processing code twice: once for the
speed and once for the batch layer. However, due to the nature of
Spring XD, the same business code can be shared between the two 
layers. This objection does not apply!

\subsection {Reactive architectures}

\subsection {Cloud deployment - does this even belong here??}
